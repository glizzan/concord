"""Utility methods/classes for actions package."""

import random
from concord.utils.converters import ConcordConverterMixin


class AutoDescription:

    def __init__(self, verb, default_string, detail_string="", past_tense=None, preposition="to"):
        self.verb = verb
        self.past_tense = past_tense
        self.default_string = default_string
        self.detail_string = detail_string if detail_string else ""
        self.preposition = preposition if preposition else "to"

    def __str__(self):
        return self.shortname

    # Helper methods

    @property
    def shortname(self):
        return f"{self.verb} {self.default_string}"

    @property
    def past_verb(self):
        if self.past_tense:
            return self.past_tense
        if self.verb[-1] == "e":
            return self.verb + "d"
        return self.verb + "ed"

    def capitalize(self, string):
        return string[:1].upper() + string[1:]

    def process_dict(self, data_dict):
        new_dict = {}
        for key, value in data_dict.items():
            if isinstance(value, list):
                value = ", ".join([str(item) for item in value])
            new_dict.update({key: value})
        return new_dict

    def details_as_text(self, change_obj):
        """Gets names and values for fields on the change object to feed to the detail_string."""
        data_dict = {}
        for field_name, field in change_obj.get_concord_fields_with_names().items():
            data_dict.update({field_name: getattr(change_obj, field_name)})
        return self.detail_string.format(**self.process_dict(data_dict))

    # calls that return user-facing strings

    def basic_description(self, capitalize=True):
        response = self.verb + " " + self.default_string
        return self.capitalize(response) if capitalize else response

    def description_present_tense(self, change_obj=None):
        text = self.details_as_text(change_obj) if change_obj and self.detail_string else self.default_string
        return f"{self.verb} {text}"

    def description_past_tense(self, change_obj=None):
        text = self.details_as_text(change_obj) if change_obj and self.detail_string else self.default_string
        return f"{self.past_verb} {text}"


class MockAction(ConcordConverterMixin):
    """Mock Actions are used in place of the Action django model in templates.  They are easier to serialize,
    lack db-dependent fields like created_at, and crucially allow us to replace certain fields or subfields
    with references to either the trigger action, or action results from previous actions in an action container."""

    is_mock = True

    def __init__(self, change, actor, target, status=None, unique_id=None):

        self.change = change
        self.target = target
        self.actor = actor
        self.status = status
        self.pk = 0  # Note that this is an invalid PK

        if not unique_id:
            unique_id = random.randrange(1, 100000)
        self.unique_id = unique_id

    def __repr__(self):
        return f"MockAction(change={self.change}, actor={self.actor}, target={self.target})"

    def __str__(self):
        return self.__repr__()

    def create_action_object(self, container_pk, save=True):
        """Creates an action object given the data set on MockAction plus the container_pk passed in."""
        from concord.actions.models import Action

        action = Action(actor=self.actor, target=self.target, change=self.change, container=container_pk)
        if save:
            action.save()

        return action


def check_permissions_for_action_group(list_of_actions):
    """Takes in a list of MockActions, generated by clients in mock mode, and runs them
    through permissions pipeline."""

    action_log = {}

    for index, action in enumerate(list_of_actions):

        is_valid = action.change.validate_state_change(actor=action.actor, target=action.target)
        action.status = "taken"

        if is_valid:
            from concord.utils.pipelines import has_permission, determine_action_status
            info = has_permission(action=action)
            status = determine_action_status(info)
            status_log = info
        else:
            status = "invalid"
            status_log = action.change.validation_error_message

        action_log[index] = {"action": action, "status": status, "log": status_log}

    status_list = [action["status"] for index, action in action_log.items()]
    if all([status == "approved" for status in status_list]):
        summary_status = "approved"
    elif all([status == "rejected" for status in status_list]):
        summary_status = "rejected"
    elif "waiting" in status_list:
        summary_status = "waiting"
    else:
        raise ValueError("Unexpected value in status list: " + ", ".join(status_list))

    return summary_status, action_log
