import json
from typing import Tuple, List, Any, Dict

from django.db.models import Model

from concord.actions.client import BaseClient
from concord.actions.models import Action  # Just needed for type hinting

from concord.conditionals.models import ApprovalCondition, VoteCondition, ConditionTemplate
from concord.conditionals import state_changes as sc


class ApprovalConditionClient(BaseClient):
    '''
    The target of the ApprovalConditionClient must always be an ApprovalCondition instance.
    '''

    def approve(self) -> Tuple[int, Any]:
        change = sc.ApproveStateChange()
        return self.create_and_take_action(change)

    def reject(self) -> Tuple[int, Any]:
        change = sc.RejectStateChange()
        return self.create_and_take_action(change)
        

class VoteConditionClient(BaseClient):
    '''
    The target of the VoteConditionClient must always be a VoteCondition instance.
    '''

    # Read only

    def publicize_votes(self) -> bool:
        return self.target.publicize_votes

    def can_abstain(self) -> bool:
        return self.target.allow_abstain

    def get_current_results(self) -> Dict:
        return self.target.current_results()

    # State changes

    def vote(self, *, vote: str) -> Tuple[int, Any]:
        change = sc.AddVoteStateChange(vote=vote)
        return self.create_and_take_action(change)


class ConditionalClient(BaseClient):
    """
    ConditionalClient is largely used as an easy way to access all the specific conditionclients at once, but can 
    also has some helper methods and one state change - add_condition_to_action.
    """

    # Target-less methods (don't require a target to be set ahead of time)

    def get_condition_item(self, *, condition_pk, condition_type):
        condition_class = self.get_condition_class(condition_type=condition_type)
        return condition_class.objects.get(pk=int(condition_pk))

    def get_vote_condition_as_client(self, *, pk: int) -> VoteConditionClient:
        vote_object = VoteCondition.objects.get(pk=pk)
        return VoteConditionClient(target=vote_object, actor=self.actor)

    def get_approval_condition_as_client(self, *, pk: int) -> ApprovalConditionClient:
        approval_object = ApprovalCondition.objects.get(pk=pk)
        return ApprovalConditionClient(target=approval_object, actor=self.actor)

    def get_possible_conditions(self, *, formatted_as="objects"):
        
        # FIXME: need to get this from a list of actual objects
        conditions = [ApprovalCondition, VoteCondition]

        if formatted_as == "objects":
            return conditions
        if formatted_as == "string":
            return [cond.__name__.lower() for cond in conditions]
        if formatted_as == "shortstring":
            return [cond.__name__.lower().split("condition")[0] for cond in conditions]

    def get_condition_class(self, *, condition_type):
        for condition in self.get_possible_conditions():
            if condition.__name__.lower() == condition_type.lower():
                return condition

    def get_condition_item_given_action_and_source(self, *, action_pk: int, source_id: str) -> Model:  
        for condition_class in self.get_possible_conditions():
            condition_items = condition_class.objects.filter(action=action_pk, source_id=source_id)
            if condition_items:
                return condition_items[0]
        return None

    def get_condition_item_on_permission(self, *, action_pk: int, permission_pk: int):
        source_id = "perm_" + str(permission_pk)
        return self.get_condition_item_given_action_and_source(action_pk=action_pk, source_id=source_id)

    def get_condition_item_on_community(self, *, action_pk: int, community_pk: int, leadership_type: str):
        source_id = leadership_type + "_" + str(community_pk)
        return self.get_condition_item_given_action_and_source(action_pk=action_pk, source_id=source_id)

    def get_or_create_condition_on_permission(self, action, permission):
        condition_item = self.get_condition_item_on_permission(action_pk=action.pk, permission_pk=permission.pk)
        if not condition_item:
            container = self.trigger_condition_creation(action=action, permission=permission)
            if container.summary_status == "committed":    # should always be the case with system???
                condition_item = self.get_condition_item_on_permission(action_pk=action.pk, permission_pk=permission.pk)
            else:
                print("Warning: container generated by get_or_create_condition_on_permission did not commit.")
        return condition_item

    def get_or_create_condition_on_community(self, action, community, leadership_type):
        condition_item = self.get_condition_item_on_community(action_pk=action.pk, community_pk=community.pk,
            leadership_type=leadership_type)
        if not condition_item:
            container = self.trigger_condition_creation(action=action, community=community, leadership_type=leadership_type)
            if container.summary_status == "committed":
                condition_item = self.get_condition_item_on_community(action_pk=action.pk, community_pk=community.pk,
                    leadership_type=leadership_type)
            else:
                print("Warning: container generated by get_or_create_condition_on_community did not commit.")
        return condition_item

    def trigger_condition_creation(self, *, action, permission=None, community=None, leadership_type=None):
        if community and leadership_type:
            if leadership_type == "owner":
                created, container, result = community.owner_condition.generate_and_run_action_container_if_permitted(trigger_action=action)
            elif leadership_type == "governor":
                created, container, result = community.governor_condition.generate_and_run_action_container_if_permitted(trigger_action=action)
            else:
                raise ValueError("Leadership type supplied to trigger_condition_creation must be owner or governor")
        elif permission:
            created, container, result = permission.condition.generate_and_run_action_container_if_permitted(trigger_action=action)
        else:
            raise ValueError("Must supply either permission or community & leadership type to trigger_condition_creation")
        return container

    # State changes

    def set_condition_on_action(self, condition_type, condition_data=None, permission_pk=None,
        community_pk=None, leadership_type=None):
        """This is almost always created as a mock to be used in a condition TemplateField. Typically when
        creating the mock we want to supply condition_type and condition_data but leave the rest to be 
        supplied later. When the action is actually run, the target should *always* be an action!"""
        change = sc.SetConditionOnActionStateChange(condition_type=condition_type, condition_data=condition_data,
            permission_pk=permission_pk, community_pk=community_pk, leadership_type=leadership_type)
        return self.create_and_take_action(change)


# class CommunityConditionalClient(ConditionalClient):
#     '''
#     Target is always a Community.  Specifically, a conditional may be set on the Governors role, 
#     the Owners role, or both, to place limits on their decision-making authority.
#     '''

#     # Target-less methods (don't require a target to be set ahead of time)

#     # Read methods which require target to be set

#     def instantiate_condition(self, condition_template):
#         """Helper method, does not save condition instance."""
#         data_dict = json.loads(condition_template.condition_data)
#         conditionModel = self.condition_lookup_helper(lookup_string=condition_template.condition_type)
#         temp_condition = conditionModel(owner=condition_template.get_owner(), **data_dict)
#         return temp_condition

#     def get_condition_info(self, condition_template):
#         temp_condition = self.instantiate_condition(condition_template)
#         display_string = temp_condition.description_for_passing_condition()
#         if condition_template.permission_data:
#             display_string += str(condition_template.permission_data)
#         return display_string

#     def get_condition_template_for_owner(self) -> ConditionTemplate:
#         for condition in self.target.condition.all():
#             if condition.condition_data.target_type == "own":
#                 return condition
#         return None

#     def get_condition_info_for_owner(self):

#         condition_template = self.get_condition_template_for_owner()
#         if condition_template:
#             return self.get_condition_info(condition_template)

#     def get_condition_template_for_governor(self) -> ConditionTemplate:
#         for condition in self.target.condition.all():
#             if condition.condition_data.target_type == "gov":
#                 return condition
#         return None

#     def get_condition_info_for_governor(self):
#         condition_template = self.get_condition_template_for_governor()
#         if condition_template:
#             return self.get_condition_info(condition_template)

#     def get_conditions_given_targets(self, *, target_pks: list):
#         return ConditionTemplate.objects.filter(permission__in=target_pks)

#     def condition_lookup_helper(self, *, lookup_string: str) -> Model:
#         return ConditionTemplate().get_condition_type_class(lookup_string=lookup_string)

#     def create_condition_item(self, *, condition_template: ConditionTemplate, action: Action) -> Model:
#         return condition_template.condition_data.create_condition_and_permissions(
#                 action=action, owner=condition_template.get_owner())
    
#     def get_condition_item_given_action(self, *, action_pk: int) -> Model:
#         # HACK
#         condition_items = ApprovalCondition.objects.filter(action=action_pk)
#         if not condition_items:
#             condition_items = VoteCondition.objects.filter(action=action_pk)
#         return condition_items[0] if condition_items else None

#     def get_or_create_condition(self, *, condition_template: ConditionTemplate, action: Action) -> Model:
#         condition_item = self.get_condition_item_given_action(action_pk=action.pk)
#         if not condition_item:
#             condition_item  = self.create_condition_item(condition_template=condition_template, action=action)
#         return condition_item 

#     # State Changes

#     def add_condition(self, *, condition_type: str, target_type: str, permission_data: Dict = None, 
#             condition_data: Dict = None):
#         change = sc.AddLeaderConditionStateChange(condition_type=condition_type,
#             permission_data=permission_data, condition_data=condition_data, target_type=target_type)
#         return self.create_and_take_action(change)

#     def change_condition(self, *, condition_pk: int, permission_data: Dict = None, 
#         condition_data: Dict = None) -> Tuple[int, Any]:
#         # FIXME: this unnecessarily requires target (a permission) to be set 
#         change = sc.ChangeLeaderConditionStateChange(condition_pk=condition_pk,
#             permission_data=permission_data, condition_data=condition_data)
#         return self.create_and_take_action(change)

#     def remove_condition(self, *, condition: Model) -> Tuple[int, Any]:
#         change = sc.RemoveLeaderConditionStateChange(condition_pk=condition.pk)
#         return self.create_and_take_action(change)

#     def add_condition_to_governors(self, *, condition_type: str, permission_data: Dict = None, 
#             condition_data: Dict = None) -> Tuple[int, Any]:
#             return self.add_condition(condition_type=condition_type, condition_data=condition_data,
#                 permission_data=permission_data, target_type="gov")

#     def add_condition_to_owners(self, *, condition_type: str, permission_data: Dict = None, 
#             condition_data: Dict = None) -> Tuple[int, Any]:
#             return self.add_condition(condition_type=condition_type, condition_data=condition_data,
#                 permission_data=permission_data, target_type="own")





